library(ggplot2)
library(purrr)
library(NetworkToolbox)
library(reticulate)
library(RMySQL)
library(reshape2)
library(spatstat)
library(gplots)
library(RColorBrewer)
library(pROC)
library(pheatmap)
library(hpar)
library(enrichR)
library(progress)
library(tidyr)
source("function2.R") # myfunc.R 의 명령어 실행
# use_python("C:\\Users\\249\\AppData\\Local\\Programs\\Python\\Python39\\python.exe")
# set global variables
cancer_types<-c("HNSC") #set cancer types that you want to analyze, ex)cancer_types<-c("HNSC","STAD",...)
classes<-c("positive","negative")
predict_obj<-"lnm" #lnm: lymph node metastasis classification, dm: distant metastasis classification
#thresholds for filtering
pcc_filter<-0.4
wilcox_pval<-0.01
```
```{r, include=FALSE}
#create directory
dir.create("plots")
dir.create("target")
dir.create("tcga_data")
dir.create("tmp")
setwd(str_c(dir,"\\tcga_data"))
for ( i in cancer_types ){
dir.create(i)
}
```
```{r, include=FALSE}
#download TCGA data
for (i in 1:length(cancer_types)){
download_TCGA(cancer_types[i],str_c(dir,"\\tcga_data\\",cancer_types[i]))
}
```
```{r,include=FALSE}
#preprocessing the clinical files
for (i in cancer_types){
pre_clinic(str_c(dir,'\\tcga_data\\',i,'\\TCGA-',i,'-clinical.csv'))
}
```
```{python, include=FALSE}
#sort tcga data into normal, tumor samples
import csv
import re
from itertools import product
import time
cancer_types_py=r.cancer_types
if len(cancer_types_py)==4:
cancer_types_py=[cancer_types_py]
dir_py=r.dir
#miRNA preproccessing
for cancer_type_py in cancer_types_py:
f = open(''.join([dir_py,'\\tcga_data\\',cancer_type_py,'\\TCGA-',cancer_type_py,'-miRNA.csv']), 'r', encoding='utf-8')
rdr = list(csv.reader(f))
rdrt=list( zip(*rdr))
with open(''.join([dir_py,'\\tcga_data\\',cancer_type_py,'\\tmp_miRNA.csv']), 'w', newline='') as f:
writer = csv.writer(f)
writer.writerow(rdrt[0])
for ele in rdrt[1:]:
if ele[0][13]=='1':
writer.writerow(ele)
for ele in rdrt[1:]:
if ele[0][13]=='0':
writer.writerow(ele)
f.close()
f = open(''.join([dir_py,'\\tcga_data\\',cancer_type_py,'\\tmp_miRNA.csv']), 'r', encoding='utf-8')
rdr = list(csv.reader(f))
rdrt=list( zip(*rdr))
with open(''.join([dir_py,'\\tcga_data\\',cancer_type_py,'\\miRNAMatrix.csv']), 'w', newline='') as f:
writer = csv.writer(f)
for ele in rdrt:
writer.writerow(ele)
f.close()
time.sleep(1)
#RNA preproccessing
for cancer_type_py in cancer_types_py:
f = open(''.join([dir_py,'\\tcga_data\\',cancer_type_py,'\\TCGA-',cancer_type_py,'-Counts.csv']), 'r', encoding='utf-8')
rdr = csv.reader(f)
rdrt=list( zip(*rdr))
with open(''.join([dir_py,'\\tcga_data\\',cancer_type_py,'\\tmp_RNA.csv']), 'w', newline='') as f:
writer = csv.writer(f)
writer.writerow(rdrt[0])
for ele in rdrt[1:]:
if ele[0][13]=='1':
writer.writerow(ele)
for ele in rdrt[1:]:
if ele[0][13]=='0':
writer.writerow(ele)
f.close()
f = open(''.join([dir_py,'\\tcga_data\\',cancer_type_py,'\\tmp_RNA.csv']), 'r', encoding='utf-8')
rdr = list(csv.reader(f))
rdrt=list( zip(*rdr))
with open(''.join([dir_py,'\\tcga_data\\',cancer_type_py,'\\RNAMatrix.csv']), 'w', newline='') as f:
writer = csv.writer(f)
for ele in rdrt:
writer.writerow(ele)
f.close()
time.sleep(1)
quit()
```
```{r, include=FALSE}
#further preprocessing
pb <- progress_bar$new(total = length(cancer_types))
for (i in cancer_types){
file.remove(str_c(dir,'\\tcga_data\\',i,'\\tmp_miRNA.csv'))
file.remove(str_c(dir,'\\tcga_data\\',i,'\\tmp_RNA.csv'))
manipul_mat(str_c(dir,'\\tcga_data\\',i,'\\miRNAMatrix.csv'),sep=',',input='id',1,1)
manipul_mat(str_c(dir,'\\tcga_data\\',i,'\\RNAMatrix.csv'),sep=',',input='id',1,1)
pb$tick()
}
```
```{r,include=FALSE}
#pick solid tissue samples
for (i in cancer_types){
pick_solid(str_c(dir,"\\tcga_data\\",i,"\\RNAMatrix.csv"))
}
```
```{r,include=FALSE}
#tmm normalization & filtering low expressed genes
pb <- progress_bar$new(total = length(cancer_types))
for (i in cancer_types){
normalized<-round(tmm(str_c(dir,'\\tcga_data\\',i,'\\RNAMatrix.csv'), op="do"),8)
write.csv(normalized,str_c(dir,'\\tcga_data\\',i,'\\normalized_RNAMatrix.csv'))
pb$tick()
}
rm(normalized)
```
```{r,include=FALSE}
ref<-read.csv(str_c(dir,"\\annotation.csv"),header = T,check.names = F)
for (i in cancer_types){
dt<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\normalized_RNAMatrix.csv"),row.names=1,check.names=F)
dt<-dt[row.names(dt)%in%ref[,1],]
vec<-row.names(dt)
id_tab<-geneid_converter(vec, ref = ref)
row.names(dt)<-id_tab[,1]
RNA_id<-id_tab[str_detect(id_tab[,2],'protein_coding') | str_detect(id_tab[,2],'lncRNA') | str_detect(id_tab[,2],'pseudogene'),]
miRNA_id<-id_tab[str_detect(id_tab[,2],'miRNA'),]
RNA<-dt[row.names(dt)%in%RNA_id[,1],] #mRNA, lncRNA, pseudogene
miRNA<-dt[row.names(dt)%in%miRNA_id[,1],]
fwrite(RNA,str_c(dir,"\\tcga_data\\",i,"\\normalized_rna.csv"),sep = ',',row.names = T,quote = F)
fwrite(miRNA,str_c(dir,"\\tcga_data\\",i,"\\normalized_mi.csv"),sep = ',',row.names = T,quote = F)
}
rm(dt,ref,vec,id_tab,RNA_id,miRNA_id,RNA,miRNA)
```
```{r,include=FALSE}
#separate normal and tumor samples
for (i in cancer_types){
dt<-separate_normal(str_c(dir,"\\tcga_data\\",i,"\\normalized_rna.csv"))
fwrite(dt,str_c(dir,"\\tcga_data\\",i,"\\normal_normalized_rna.csv"),sep = ',',row.names = T,quote = F)
remove_normal(str_c(dir,"\\tcga_data\\",i,"\\normalized_rna.csv"))
dt<-separate_normal(str_c(dir,"\\tcga_data\\",i,"\\normalized_mi.csv"))
fwrite(dt,str_c(dir,"\\tcga_data\\",i,"\\normal_normalized_mi.csv"),sep = ',',row.names = T,quote = F)
remove_normal(str_c(dir,"\\tcga_data\\",i,"\\normalized_mi.csv"))
}
```
```{r,include=FALSE}
#select samples which are common to clinical file
for (i in cancer_types){
colname_slice(str_c(dir,'\\tcga_data\\',i,'\\normalized_rna.csv'),1,12) #cut colnames
colname_slice(str_c(dir,'\\tcga_data\\',i,'\\normalized_mi.csv'),1,12)
}
pb <- progress_bar$new(total = length(cancer_types))
for (i in cancer_types){
#intersect rna and clinical
df<-read.csv(str_c(dir,'\\tcga_data\\',i,'\\normalized_rna.csv'),row.names = 1, check.names = F)
df<-df[,!duplicated(colnames(df))]
clinic<-read.csv(str_c(dir,'\\tcga_data\\',i,'\\TCGA-',i,'-clinical.csv'),row.names = 1, check.names = F)
inter<-intersect(colnames(df),clinic[,1])
df<-df[,colnames(df)%in%inter]
write.csv(df,str_c(dir,'\\tcga_data\\',i,'\\normalized_rna.csv'),quote = F)
#intersect miRNA and clinical
df<-read.csv(str_c(dir,'\\tcga_data\\',i,'\\normalized_mi.csv'),row.names = 1, check.names = F)
df<-df[,!duplicated(colnames(df))]
inter<-intersect(colnames(df),clinic[,1])
df<-df[,colnames(df)%in%inter]
write.csv(df,str_c(dir,'\\tcga_data\\',i,'\\normalized_mi.csv'),quote = F)
clinic<-clinic[clinic[,1]%in%inter,]
write.csv(clinic,str_c(dir,'\\tcga_data\\',i,'\\TCGA-',i,'-clinical.csv'),quote = F)
pb$tick()
}
rm(df,clinic,inter,dt)
```
```{r,include=FALSE}
#separate tumor samples based on TNM stage index
for (i in cancer_types){
tnm_separator(dir = str_c(dir,'\\tcga_data\\',i,'\\normalized_rna.csv') #counts
,clinic_dir = str_c(dir,'\\tcga_data\\',i,'\\TCGA-',i,'-clinical.csv')
,setwd = str_c(dir,'\\tcga_data\\',i), op=predict_obj)
tnm_separator(dir = str_c(dir,'\\tcga_data\\',i,'\\normalized_mi.csv') #miRNAs
,clinic_dir = str_c(dir,'\\tcga_data\\',i,'\\TCGA-',i,'-clinical.csv')
,setwd = str_c(dir,'\\tcga_data\\',i), op=predict_obj)
}
for (i in cancer_types){
for (j in classes){
colname_add(str_c(dir,'\\tcga_data\\',i,'\\',j,'_normalized_rna.csv'),'-01')
colname_add(str_c(dir,'\\tcga_data\\',i,'\\',j,'_normalized_mi.csv'),'-01')
}
}
```
```{r,include=FALSE}
#calculate PCC of miRNA-RNA pairs and remove miRNA-RNA pair with |PCC|=<0.4
pb <- progress_bar$new(total = length(cancer_types))
for (i in cancer_types){
for (j in classes){
mi<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\",j,"_normalized_mi.csv"),row.names = 1,check.names = F)
rna<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\",j,"_normalized_rna.csv"),row.names = 1, check.names = F)
id<-rownames(mi)
target<-rownames(rna)
pair<-tidyr::crossing(id, target)
pair<-cal_correlation(pair,mi,rna,pcc_filter)
mi<-mi[rownames(mi)%in%unique(pair[,1]),]
fwrite(mi,str_c(dir,"\\tcga_data\\",i,"\\",j,"_corr_validated_mi.csv"),sep = ',',row.names = T,quote = F)
rna<-rna[rownames(rna)%in%unique(pair[,2]),]
fwrite(rna,str_c(dir,"\\tcga_data\\",i,"\\",j,"_corr_validated_rna.csv"),sep = ',',row.names = T,quote = F)
write.csv(pair,str_c(dir,"\\tcga_data\\",i,"\\",j,"_miRNA-RNA_pair.csv"),row.names=F,quote=F)
}
pb$tick()
}
rm(mi,rna,pair,id,target)
```
```{r,include=FALSE}
#remove miRNA-RNA pairs whcih are common to both positive and negative sample set
for (i in cancer_types){
positive<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\positive_miRNA-RNA_pair.csv"), check.names = F)[,1:2]
negative<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\negative_miRNA-RNA_pair.csv"), check.names = F)[,1:2]
admat<-unique(rbind(positive,negative))
inter<-inner_join(positive, negative)
admat<-dplyr::setdiff(admat,inter)
write.csv(admat,str_c(dir,"\\tcga_data\\",i,"\\admat.csv"),row.names = F,quote = F)
cat(str_c("intersect: ",nrow(inter)))
}
rm(positive,negative,admat,inter)
```
```{r,include=FALSE}
#generate label (postivie and negative) file
for (i in cancer_types){
positive<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\positive_corr_validated_mi.csv"),row.names = 1,check.names = F)
p_label<-cbind(colnames(positive),rep(1,ncol(positive)))
negative<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\negative_corr_validated_mi.csv"),row.names = 1,check.names = F)
n_label<-cbind(colnames(negative),rep(0,ncol(negative)))
tab_label<-rbind(p_label,n_label)
colnames(tab_label)<-c("sample_id","labels")
write.csv(tab_label,str_c(dir,"\\tcga_data\\",i,"\\tab_label.csv"),row.names = F,quote = F)
}
rm(positive,negative,p_label,n_label,tab_label)
```
```{r, include=FALSE}
#calculate delta PCC & perform wilcoxon test & derive input file for machine learning
for (i in cancer_types){
admat<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\admat.csv"),check.names=F)
positive_rna<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\positive_normalized_rna.csv"),row.names = 1, check.names = F)
negative_rna<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\negative_normalized_rna.csv"),row.names = 1, check.names = F)
positive_mi<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\positive_normalized_mi.csv"),row.names = 1, check.names = F)
negative_mi<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\negative_normalized_mi.csv"),row.names = 1, check.names = F)
normal_rna<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\normal_normalized_rna.csv"),row.names = 1, check.names = F)
normal_mi<-read.csv(str_c(dir,"\\tcga_data\\",i,"\\normal_normalized_mi.csv"),row.names = 1, check.names = F)
positive_delta<-cal_delta_pcc(admat,normal_rna,normal_mi,positive_rna,positive_mi)
negative_delta<-cal_delta_pcc(admat,normal_rna,normal_mi,negative_rna,negative_mi)
wilcox<-delta_wilcox_test(positive_delta,negative_delta,wilcox_pval)
write.csv(wilcox,str_c(dir,"\\tcga_data\\",i,"\\wilcox.csv"),quote=F,row.names=F)
row.names(wilcox)<-str_c(wilcox[,1],"_",wilcox[,2])
positive_delta<-na.omit(positive_delta)
row.names(positive_delta)<-str_c(positive_delta[,1],"_",positive_delta[,2])
negative_delta<-na.omit(negative_delta)
row.names(negative_delta)<-str_c(negative_delta[,1],"_",negative_delta[,2])
positive_delta<-positive_delta[row.names(positive_delta)%in%row.names(wilcox),]
negative_delta<-negative_delta[row.names(negative_delta)%in%row.names(wilcox),]
negative_delta<-negative_delta[,3:ncol(negative_delta)]
ml_input<-merge(positive_delta,negative_delta,by="row.names")
ml_input<-ml_input[,-1]
write.csv(ml_input,str_c(dir,"\\tcga_data\\",i,"\\ml_input.csv"),quote=F,row.names=F)
}
```
```{r,include=FALSE}
# install packages for python
py_install("pandas")
py_install("scikit-learn")
py_install("matplotlib")
```
###machine learning stage###
```{python}
# import modules
from sklearn.model_selection import train_test_split
from sklearn.decomposition import PCA
import pandas as pd
from sklearn import svm
import numpy as np
import math
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib import colors
from sklearn.model_selection import train_test_split
from sklearn import datasets
from matplotlib.colors import ListedColormap
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import StratifiedShuffleSplit,StratifiedKFold
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import GridSearchCV, LeaveOneOut, cross_val_predict
from sklearn.model_selection import KFold
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn import svm
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import roc_auc_score
from sklearn.metrics import roc_auc_score
import math
import datetime
import multiprocessing as mp
from sklearn.ensemble import StackingClassifier
from sklearn.pipeline import make_pipeline
from sklearn.svm import LinearSVC
import random
```
```{python}
#define function for scoring
def get_measures_gridloo(label, score):
label = np.array(label)
score = np.array(score)
N  = len(label)
TP = sum((label == 1) & (score == 1))
TN = sum((label == 0) & (score == 0))
FP = sum((label == 0) & (score == 1))
FN = sum((label == 1) & (score == 0))
# init all measures to nan
measures = {measure: float("nan") for measure in ("Sen", "Spe", "Acc", "PPV", "NPV", "MCC","AUC")}
measures["TP"] = TP
measures["TN"] = TN
measures["FP"] = FP
measures["FN"] = FN
S = (TP + FN) / N
P = (TP + FP) / N
if (TP + FN) > 0: #recall
measures["Sen"] = round(TP/(TP+FN), 4)
if (TN + FP) > 0:
measures["Spe"] = round(TN/(TN+FP), 4)
if (TP + FP + FN + TN) > 0:
measures["Acc"] = round((TP+TN)/(TP+FP+FN+TN), 4)
if (TP + FP) > 0: #precision
measures["PPV"] = round(TP/(TP+FP), 4)
if (TN + FN) > 0:
measures["NPV"] = round(TN/(TN+FN), 4)
#     if (S*P*(1-S)*(1-P)) > 0:
#         measures["MCC"] = round((TP/N - S*P)/(math.sqrt(S*P*(1-S)*(1-P))), 4)
if (2*TP+FP+FN) > 0:
measures["F1"] = round((2*TP)/(2*TP+FP+FN), 4)
measures["AUC"]= roc_auc_score(label, score)
return pd.DataFrame([measures],
columns=["TP", "TN", "FP",
"FN", "Sen", "Spe", "Acc", "PPV", "NPV", "F1","AUC"])
```
```{python}
# read input files
cancer='HNSC'
train=pd.read_csv(dir_py+"\\tcga_data\\"+cancer+"\\ml_input.csv")
target=pd.read_csv(dir_py+"\\tcga_data\\"+cancer+"\\tab_label.csv",index_col=0).values.ravel()
indices = train.columns[2:]
train=train.iloc[:,2:].T.values
```
```{python,include=FALSE}
# run machine learning model (ensemble learner)
train_aucs=[]
test_aucs=[]
train_scores=[]
test_scores=[]
loopn=5 #number of repetition while splitting train/test dataset with different random state.
np.random.seed(10)
random_states=np.random.choice(range(101), loopn, replace=False)
scoring='f1'
pca_comp=[]
for i in range(loopn):
train_X,test_X, train_y, test_y ,indices_train,indices_test= train_test_split(train,
target,indices,
test_size = 0.3,
stratify=target,
random_state=random_states[i]
)
print("train_x.shpae:")
print(train_X.shape)
standardScaler = StandardScaler()
standardScaler.fit(train_X)
X_standard = standardScaler.transform(train_X)
X_standard_test = standardScaler.transform(test_X)
#calculate max n_components
estimator = PCA(n_components=0.99,random_state=42)
pca_X_train = estimator.fit_transform(X_standard)
n_components=range(10,min(pca_X_train.shape),10)
print(n_components)
best_pca_train_aucs=[]
best_pca_test_aucs=[]
best_pca_train_scores=[]
best_pca_test_scores=[]
for j in n_components:
estimator = PCA(n_components=j,random_state=42)
pca_X_train = estimator.fit_transform(X_standard)
pca_X_test = estimator.transform(X_standard_test)
cvx = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
cost = [-5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15]
gam = [3, 1, -1, -3, -5, -7, -9, -11, -13, -15]
parameters =[{'kernel': ['rbf'], 'C': [2**x for x in cost],'gamma':[2**x for x in gam]}]
svc_grid_search=GridSearchCV(estimator=SVC(random_state=42),
param_grid=parameters,cv=cvx,scoring=scoring,verbose=0)
svc_grid_search.fit(pca_X_train, train_y)
param_grid = {'penalty':['l1', 'l2'],
"C":[0.00001,0.0001,0.001, 0.01, 0.1, 1, 10, 100, 1000],
"solver":["newton-cg", "lbfgs","liblinear","sag","saga"]
#               "algorithm":['auto', 'ball_tree', 'kd_tree', 'brute']
}
LR_grid = LogisticRegression(max_iter=1000, random_state=42)
LR_grid_search = GridSearchCV(LR_grid, param_grid=param_grid, cv=cvx ,scoring=scoring,n_jobs=10,verbose=0)
LR_grid_search.fit(pca_X_train, train_y)
estimators = [
('lr', LR_grid_search.best_estimator_),
('svc', svc_grid_search.best_estimator_),
]
clf = StackingClassifier(estimators=estimators,
final_estimator=LinearSVC(C=5, random_state=42),n_jobs=10,verbose=0)
clf.fit(pca_X_train, train_y)
estimators = [
('lr', LR_grid_search.best_estimator_),
('svc', svc_grid_search.best_estimator_),
]
param_grid = {'final_estimator':[LogisticRegression(C=0.00001),LogisticRegression(C=0.0001),
LogisticRegression(C=0.001),LogisticRegression(C=0.01),
LogisticRegression(C=0.1),LogisticRegression(C=1),
LogisticRegression(C=10),LogisticRegression(C=100),
LogisticRegression(C=1000)]}
Stacking_grid =StackingClassifier(estimators=estimators,)
Stacking_grid_search = GridSearchCV(Stacking_grid, param_grid=param_grid, cv=cvx,
scoring=scoring,n_jobs=10,verbose=0)
Stacking_grid_search.fit(pca_X_train, train_y)
Stacking_grid_search.best_estimator_
train_pre_y = cross_val_predict(Stacking_grid_search.best_estimator_, pca_X_train,train_y, cv=cvx)
train_res1=get_measures_gridloo(train_y,train_pre_y)
test_pre_y = Stacking_grid_search.predict(pca_X_test)
test_res1=get_measures_gridloo(test_y,test_pre_y)
best_pca_train_aucs.append(train_res1.loc[:,"AUC"])
best_pca_test_aucs.append(test_res1.loc[:,"AUC"])
best_pca_train_scores.append(train_res1)
best_pca_test_scores.append(test_res1)
train_aucs.append(np.max(best_pca_train_aucs))
test_aucs.append(best_pca_test_aucs[np.argmax(best_pca_train_aucs)].item())
train_scores.append(best_pca_train_scores[np.argmax(best_pca_train_aucs)])
test_scores.append(best_pca_test_scores[np.argmax(best_pca_train_aucs)])
pca_comp.append(n_components[np.argmax(best_pca_train_aucs)])
print("n_components:")
print(n_components[np.argmax(best_pca_train_aucs)])
```
```{python}
# training (5-fold cross-validation) results
print("train")
pd.concat(train_scores).describe()
```
```{python}
# independent testing results
print("test")
pd.concat(test_scores).describe()
```
quit
# install.packages("miRBaseConverter") # this is the common way to install packages in R. If this code doesn't work, try the code below instead.
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
#
# BiocManager::install("edgeR")
# BiocManager::install("BioinformaticsFMRP/TCGAbiolinksGUI.data")
# BiocManager::install("BioinformaticsFMRP/TCGAbiolinks")
dir<-getwd()
setwd(dir)
library(beepr)
library(readxl)
library(TCGAbiolinks)
library(dplyr)
library(DT)
library(SummarizedExperiment)
library(stringr)
library(doParallel)
library(data.table)
library(limma)
library(stringi)
library(parallel)
library(psych)
library(ggm)
library(corpcor)
library(ggplot2)
library(purrr)
library(NetworkToolbox)
library(reticulate)
library(RMySQL)
library(reshape2)
library(spatstat)
library(gplots)
library(RColorBrewer)
library(pROC)
library(pheatmap)
library(hpar)
install.packages("miRBaseConverter")
# this is the common way to install packages in R. If this code doesn't #work,try the code below instead.
if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
#
BiocManager::install("edgeR")
BiocManager::install("BioinformaticsFMRP/TCGAbiolinksGUI.data")
